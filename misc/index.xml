<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Miscs on My New Hugo Site</title>
    <link>http://shidetake.com/misc/</link>
    <description>Recent content in Miscs on My New Hugo Site</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Sun, 04 Jun 2017 22:44:34 +0900</lastBuildDate>
    
	<atom:link href="http://shidetake.com/misc/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>KindleのハイライトをLINEに通知する 2</title>
      <link>http://shidetake.com/misc/line_highlights_2/</link>
      <pubDate>Sun, 04 Jun 2017 22:44:34 +0900</pubDate>
      
      <guid>http://shidetake.com/misc/line_highlights_2/</guid>
      <description>前回はクローラーを作成してハイライトを取得するところまでだった。 今回はサーバで起動してLINE通知するところまでを作る。
サーバで起動 前回はSeleniumを使ったが、サーバで実行する場合はGUIアプリケーションにはできないので、 POLTERGEISTを使う。
def initialize - Capybara.current_driver = :selenium + Capybara.current_driver = :poltergeist - Capybara.javascript_driver = :selenium + Capybara.javascript_driver = :poltergeist Capybara.app_host = &#39;https://kindle.amazon.co.jp&#39; Capybara.default_max_wait_time = 5 - Capybara.register_driver :selenium do |app| + Capybara.register_driver :poltergeist do |app| - # 最新のSeleniumではFirefoxが動作しない問題があるのでchromeを使う - Capybara::Selenium::Driver.new(app, :browser =&amp;gt; :chrome) + Capybara::Poltergeist::Driver.new(app, {:timeout =&amp;gt; 120, js_errors: false}) end + page.driver.headers = {&#39;User-Agent&#39; =&amp;gt; &#39;Mac Safari&#39;} end  Amazonのウェブサイト固有の問題で、ユーザーエージェントの変更が必要なので、Mac Safariとしている。
これでサーバ（今回はUbuntuを使った）で動作するようになった。
LINE通知 line-bot-apiを使った。だいたい以下のような感じ。Channel Secret, Channel Access Token, userIdはLINE developersから取得して入力すること。 push_highlightメソッドを使って、前回標準出力していた文字列をLINEに送れる。</description>
    </item>
    
    <item>
      <title>KindleのハイライトをLINEに通知する 1</title>
      <link>http://shidetake.com/misc/line_highlights_1/</link>
      <pubDate>Sat, 27 May 2017 13:08:32 +0900</pubDate>
      
      <guid>http://shidetake.com/misc/line_highlights_1/</guid>
      <description>読書メモのためにハイライトした文章をコピペできる形にしたい。 KindleにはハイライトをメールやTwitterでシェアする機能があるが、これはアクションが増えて読書を妨げるので使いたくない。
ハイライトした内容は https://kindle.amazon.co.jp/your_highlights で見えるので、これを取得して通知するクローラーを作ればよい。
クローラー作成 RubyのCapybaraを使った。
動作環境 ruby 2.3.0p0 (2015-12-25 revision 53290) [x86_64-darwin15] selenium-webdriver (2.53.0, 2.52.0) capybara (2.14.0)  ソースコード # coding: utf-8 require &#39;capybara&#39; require &#39;capybara/dsl&#39; require &#39;capybara/poltergeist&#39; require &#39;selenium-webdriver&#39; class LineKindleHighlights include Capybara::DSL KINDLE_EMAIL = &#39;your@email&#39; KINDLE_PASSWORD = &#39;your_password&#39; CRAWL_PAGE_NUM = 2 def initialize Capybara.current_driver = :selenium Capybara.javascript_driver = :selenium Capybara.app_host = &#39;https://kindle.amazon.co.jp&#39; Capybara.default_max_wait_time = 5 Capybara.register_driver :selenium do |app| # 最新のSeleniumではFirefoxが動作しない問題があるのでchromeを使う Capybara::Selenium::Driver.new(app, :browser =&amp;gt; :chrome) end end def scrape login # ページ読み込み待ち sleep 5 go_to_highlights CRAWL_PAGE_NUM.</description>
    </item>
    
    <item>
      <title>Time Machineの容量制限</title>
      <link>http://shidetake.com/misc/time_capsule/</link>
      <pubDate>Sun, 14 May 2017 21:01:17 +0900</pubDate>
      
      <guid>http://shidetake.com/misc/time_capsule/</guid>
      <description> Time Capsuleをバックアップ用途だけでなく、NASとしても使いたい。 Time Machineを使うと、容量がいっぱいになるまでバックアップを取り続けてしまうので、 何らかの方法で容量を制限する必要がある。
パーティションを切って、バックアップ領域とデータ領域に分けるという方法が主流のようだ。 ただ、裏ワザ的な使い方のためあまり推奨しないという意見も多い。
そこで、別の方法を採用した。
ダミーファイルを置く ダミーファイルを置くことで、パーティションを切ることなく、Time Machineの侵食を逃れる。 新しくデータを置きたい場合は、ダミーファイルの一部をデータと置き換えればよい。
1GBのダミーファイルを100個と、10GBのダミーファイルを10個用意して、 計200GB分のデータ領域を確保することにした。
ダミーファイルの作成は以下のコマンドを使った。
dd if=/dev/zero of=./dummy_10GB bs=1000000 count=10000  実際にはfor文で以下のように使う。 ネットワーク越しなのでかなり時間がかかることに注意。
cd /Volumes/TimeCapsule for ((i=0; i &amp;lt; 100; i++)); do dd if=/dev/zero of=./dummy_1GB_$i bs=1000000 count=1000; done for ((i=0; i &amp;lt; 10; i++)); do dd if=/dev/zero of=./dummy_10GB_$i bs=1000000 count=10000; done  </description>
    </item>
    
    <item>
      <title>Amazon Dash ButtonからLINE通知</title>
      <link>http://shidetake.com/misc/dash_button/</link>
      <pubDate>Thu, 11 May 2017 22:31:20 +0900</pubDate>
      
      <guid>http://shidetake.com/misc/dash_button/</guid>
      <description> dasher導入 他の人が詳しく書いているので割愛。
個人的にはAmazon Dash Button と slackを連携させるという記事がとても参考になった。
LINEへのPUSH通知設定 LINE側の設定はLINE BOTでPUSH通知するを参照。
CHANNEL_ACCESS_TOKENとUSERIDは上記事で取得したもの。 MAC_ADDRESSはdasher導入時に取得したものを書くこと。
{&amp;quot;buttons&amp;quot;: [ { &amp;quot;name&amp;quot;: &amp;quot;joy&amp;quot;, &amp;quot;address&amp;quot;: &amp;quot;MAC_ADDRESS&amp;quot;, &amp;quot;url&amp;quot;: &amp;quot;https://api.line.me/v2/bot/message/push&amp;quot;, &amp;quot;method&amp;quot;: &amp;quot;POST&amp;quot;, &amp;quot;headers&amp;quot;: { &amp;quot;Content-Type&amp;quot;: &amp;quot;application/json&amp;quot;, &amp;quot;Authorization&amp;quot;: &amp;quot;Bearer {CHANNEL_ACCESS_TOKEN}&amp;quot;}, &amp;quot;json&amp;quot;: true, &amp;quot;body&amp;quot;: { &amp;quot;to&amp;quot;: &amp;quot;USERID&amp;quot;, &amp;quot;messages&amp;quot;: [ { &amp;quot;type&amp;quot;: &amp;quot;text&amp;quot;, &amp;quot;text&amp;quot;: &amp;quot;JOY!&amp;quot; } ] } } ]}  </description>
    </item>
    
    <item>
      <title>LINE BOTでPUSH通知する</title>
      <link>http://shidetake.com/misc/line_push/</link>
      <pubDate>Mon, 17 Apr 2017 23:11:57 +0900</pubDate>
      
      <guid>http://shidetake.com/misc/line_push/</guid>
      <description>登録  PUSH通知する場合はDeveloper Trialで登録  Google Apps ScriptでユーザID取得  友達に追加したユーザのIDを登録したメールアドレスにメールする 以下のコードでウェブアプリケーションとして導入する  CHANNEL_ACCESS_TOKENはLINE depelopersで取得できる example@gmail.comは任意のgmailアドレス アプリケーションにアクセスできるユーザーは全員（匿名ユーザーを含む）   var CHANNEL_ACCESS_TOKEN = &#39;CHANNEL_ACCESS_TOKEN&#39;; function doPost(e) { Logger.log(&#39;doPost&#39;) var events = JSON.parse(e.postData.contents).events; events.forEach (function(event) { if (event.type == &amp;quot;follow&amp;quot;) { mailUserId(event); } }); } function mailUserId(e) { MailApp.sendEmail(&#39;example@gmail.com&#39;, &#39;mailId&#39;, e.source.userId); }  curlでMessaging APIのPUSH通知を使う  CHANNEL_ACCESS_TOKENは上で使ったものと同じ USERIDはプッシュ先  今回は上で取得した自分のユーザIDを使う   curl -X POST \ -H &#39;Content-Type:application/json&#39; \ -H &#39;Authorization: Bearer {CHANNEL_ACCESS_TOKEN}&#39; \ -d &#39;{ &amp;quot;to&amp;quot;: &amp;quot;USERID&amp;quot;, &amp;quot;messages&amp;quot;:[ { &amp;quot;type&amp;quot;: &amp;quot;text&amp;quot;, &amp;quot;text&amp;quot;: &amp;quot;Hello, world!</description>
    </item>
    
  </channel>
</rss>